%{
/*
 * CS-4145 Section 71
 * Assignment 1: Flex Scanner + Bison Parser
 * File: parsey.l - Flex scanner file
 * Author: Jacob A. Geldbach
 * Date: 09/01/2025
 */

/* This *order* of these includes is mandatory due to parser.tab.h that was generated by bison has a dependency on scanType.h */
#include "scanType.h"  /* token_data_t struct for passing token information between lexer and parser */
#include "globals.h"   /* Global types and vars for the compiler */
#include "util.h"      /* Utility functions */
#include "yyerror.h"
#include "parser.tab.h"  /* Token defintions generated by the bison such as NUMBER, ID, etc */

int line_num = 1;  /* Current line number, start at line 1 */
char *lastToken; /* Last token scanned */
/* Decodes C- alloed escape sequences in a string */
/* 
 * Flex/lex returns the raw lexines in order for the compiler implementor to have complete control over handling what is scanned in 
 * This method decodes them based on which charachter follows the escape character that is scanned in 
 */
void decode_escaped_string(const char *src, char *dest) {
    const char *end = src + strlen(src);

    while (src < end) {
        if (*src == '\\') {            /* Detect the scanned in escape character */
            src++;                     /* Move to the character following the escape character */
            switch (*src) {
                case 'n': *dest++ = '\n'; break; 	/* Newline */
                case 'r': *dest++ = '\r'; break; 	/* Carriage return */
                case '\\': *dest++ = '\\'; break; 	/* Literal backslash */
                case '\"': *dest++ = '\"'; break; 	/* Literal double quote */
                case '0': *dest++ = '\0'; break; 	/* Null character */
                default: *dest++ = *src; break;		/* Pass through and essentially erase '\' when not followed by a valid escape character */
            }
        } else {
            *dest++ = *src;            /* Regular character, just copy it */
        }
        src++;
    }

    *dest = '\0';                      /* Tidy up the destination string with a null terminator */
}

static int set_val(int line_num, int token_class, char *svalue)
{
    /* Instantiate the pass-back data structure and assign its pointer to the YYSTYPEs union token_data_t pointer */
    yylval.token_data = new token_data_t;

    /* Fill the pass-back structure with information regarding this token */
    yylval.token_data->line_num = line_num;
    yylval.token_data->token_str = strdup(svalue);  /* Duplicating string and assigning pointer to first char into member variable token_str*/

    yylval.token_data->token_class = token_class; /* Assigning the token class to member variable token_class */

    if (token_class == NUMBERCONST) {
        yylval.token_data->nvalue = atof(svalue); 
    }
    else if (token_class == ID) {
        yylval.token_data->svalue = strdup(svalue); /* Duplicating string and assigning pointer to first char into member variable svalue */
    }
    else if (token_class == CHARCONST) {
    	/* Decode escape sequences in the passed in string (in-case of multi-char single quotes) */
    	char decoded_string[1024]; /* Temporary buffer for decoded string, assuming max length of 1024 */
    	decode_escaped_string(svalue, decoded_string); /* Decode escape sequences */
        yylval.token_data->cvalue = decoded_string[1]; /* Assigning the char value to member variable cvalue, ignore first single quote */
    }
    else if (token_class == STRINGCONST) {
    	/* Decode escape sequences in the string */
    	char decoded_string[1024]; /* Temporary buffer for decoded string, assuming max length of 1024 */
    	decode_escaped_string(svalue, decoded_string); /* Decode escape sequences */
        yylval.token_data->svalue = strdup(decoded_string); /* Duplicating string and assigning pointer to first char into member variable svalue */
    }
   
    /* Return token_class that was passed in now that yylval has all the token_data_t data */
    return token_class;
}

%}

%option noyywrap

/* REFACTOR REGULAR EXPRESSIONS, once finished with chapter 2 in the book I plan to make these regular expressions more efficient/less ugly if possible */
%%
"true"                                      { lastToken = strdup(yytext); return set_val(line_num, TRUE, yytext); }
"false"   						            { lastToken = strdup(yytext); return set_val(line_num, FALSE, yytext); }
"int"                                       { lastToken = strdup(yytext); return set_val(line_num, INT, yytext); }
"char"                                      { lastToken = strdup(yytext); return set_val(line_num, CHAR, yytext); }
"bool"                                      { lastToken = strdup(yytext); return set_val(line_num, BOOL, yytext); }
"if"                                        { lastToken = strdup(yytext); return set_val(line_num, IF, yytext); }
"else"                                      { lastToken = strdup(yytext); return set_val(line_num, ELSE, yytext); }
"while"                                     { lastToken = strdup(yytext); return set_val(line_num, WHILE, yytext); }
"for"                                       { lastToken = strdup(yytext); return set_val(line_num, FOR, yytext); }
"do"                                        { lastToken = strdup(yytext); return set_val(line_num, DO, yytext); }
"return"                                    { lastToken = strdup(yytext); return set_val(line_num, RETURN, yytext); }
"break"                                     { lastToken = strdup(yytext); return set_val(line_num, BREAK, yytext); }
"to"                                        { lastToken = strdup(yytext); return set_val(line_num, TO, yytext); }
"by"                                        { lastToken = strdup(yytext); return set_val(line_num, BY, yytext); }
"then"                                      { lastToken = strdup(yytext); return set_val(line_num, THEN, yytext); }
"static"							        { lastToken = strdup(yytext); return set_val(line_num, STATIC, yytext); }
":="                                        { lastToken = strdup(yytext); return set_val(line_num, ASGN, yytext); }
"><"                                    	{ lastToken = strdup(yytext); return set_val(line_num, NEQ, yytext); }
"+="                                        { lastToken = strdup(yytext); return set_val(line_num, ADDASS, yytext); }
"++"                                        { lastToken = strdup(yytext); return set_val(line_num, INC, yytext); }
"--"                                        { lastToken = strdup(yytext); return set_val(line_num, DEC, yytext); }
"-="                                        { lastToken = strdup(yytext); return set_val(line_num, SUBASS, yytext); }
"*="                                        { lastToken = strdup(yytext); return set_val(line_num, MULASS, yytext); }
"/="                                        { lastToken = strdup(yytext); return set_val(line_num, DIVASS, yytext); }
"="                                         { lastToken = strdup(yytext); return set_val(line_num, EQ, yytext); }
"<"                                         { lastToken = strdup(yytext); return set_val(line_num, LT, yytext); }
">"                                         { lastToken = strdup(yytext); return set_val(line_num, GT, yytext); }
"<="                                        { lastToken = strdup(yytext); return set_val(line_num, LEQ, yytext); }
">="                                        { lastToken = strdup(yytext); return set_val(line_num, GEQ, yytext); }
"and"                                       { lastToken = strdup(yytext); return set_val(line_num, AND, yytext); }
"or"                                        { lastToken = strdup(yytext); return set_val(line_num, OR, yytext); }
"not"                                       { lastToken = strdup(yytext); return set_val(line_num, NOT, yytext); }
"*"                                         { lastToken = strdup(yytext); return set_val(line_num, TIMES, yytext); }
"/"                                         { lastToken = strdup(yytext); return set_val(line_num, DIV, yytext); }
"+"                                         { lastToken = strdup(yytext); return set_val(line_num, PLUS, yytext); }
"-"                                         { lastToken = strdup(yytext); return set_val(line_num, MINUS, yytext); }
"?"                                         { lastToken = strdup(yytext); return set_val(line_num, TERNARY, yytext); }
"%"                                         { lastToken = strdup(yytext); return set_val(line_num, MOD, yytext); }
"{"                                         { lastToken = strdup(yytext); return set_val(line_num, LBRACE, yytext); }
"}"                                         { lastToken = strdup(yytext); return set_val(line_num, RBRACE, yytext); }
"["                                         { lastToken = strdup(yytext); return set_val(line_num, LBRACKET, yytext); }
"]"                                         { lastToken = strdup(yytext); return set_val(line_num, RBRACKET, yytext); }
","                                         { lastToken = strdup(yytext); return set_val(line_num, COMMA, yytext); }
"("                                         { lastToken = strdup(yytext); return set_val(line_num, LPAREN, yytext); }
")"                                         { lastToken = strdup(yytext); return set_val(line_num, RPAREN, yytext); }
";"                                         { lastToken = strdup(yytext); return set_val(line_num, SEMI, yytext); }
":"                                         { lastToken = strdup(yytext); return set_val(line_num, COLON, yytext); }
[0-9]+								        { lastToken = strdup(yytext); return set_val(line_num, NUMBERCONST, yytext); } /* Grammar requirements for NUMCONST token class */
[A-Za-z][A-Za-z0-9]*    					{ lastToken = strdup(yytext); return set_val(line_num, ID, yytext); } /* Grammar requirements for ID token class */
\'[ \tA-Za-z0-9\"\'\@ \t]\'            		{ lastToken = strdup(yytext); return set_val(line_num, CHARCONST, yytext); } /* Grammar requirements for CHARCONST token class, \t in front and back to 	account for ignored whitespace as per the grammar */


\'\\[n0\\'\"\^@txd]\'    			        { lastToken = strdup(yytext); return set_val(line_num, CHARCONST, yytext); } /* Grammar requirements for CHARCONST VALID newline tokens */
\"([^\"\\\n]|\\.)*\"				        { lastToken = strdup(yytext); return set_val(line_num, STRINGCONST, yytext); } /* Grammar requirements for STRING token class */
[ \t]                  				        ; /* Ignore whitespace */
"//"[^\n]*					                ; /* Ignore single line comments */
\n	                     			        { lastToken = strdup(yytext); line_num++; } /*  */
\'[A-Za-z0-9 \^]+\'   				        { lastToken = strdup(yytext); printf("WARNING(%d): character is %d characters long and not a single character: '%s'.  The first char will be used.\n",
											line_num, strlen(yytext) - 2, yytext); num_warnings++; return set_val(line_num, CHAR, yytext); } 
													/* Warning for single quote strings handled as CHAR */

''          					            { lastToken = strdup(yytext); printf("ERROR(%d): Empty character ''.  Characters ignored.\n", line_num); num_errors++; } /* Error for empty single quotes ('') */
\'\'\\[t]\'    					            { lastToken = strdup(yytext); printf("ERROR(%d): Empty single quotes %s\n", line_num, yytext); num_errors++; } /* Error for empty single quotes ('') */
\'.*^'           				            { lastToken = strdup(yytext); printf("ERROR(%d): Malformed char %s\n", line_num, yytext); num_errors++; } /* Error for unclosed char quotes ('.)*/
.                      				        { lastToken = strdup(yytext); printf("ERROR(%d): Invalid or misplaced input character: '%c'. Character Ignored.\n", line_num, yytext[0]); num_errors++; }
%%
