%{
/*
 * CS-4145 Section 71
 * Assignment 1: Flex Scanner + Bison Parser
 * File: parsey.l - Flex scanner file
 * Author: Jacob A. Geldbach
 * Date: 09/01/2025
 */

/* This *order* of these includes is mandatory due to parser.tab.h that was generated by bison has a dependency on scanType.h */
#include "scanType.h"  /* token_data_t struct for passing token information between lexer and parser */
#include "parser.tab.h"  /* Token defintions generated by the bison such as NUMBER, ID, etc */

int line_num = 1;  /* Current line number, start at line 1 */
int num_errors;    /* Number of errors */

/* Decodes C- alloed escape sequences in a string */
/* 
 * Flex/lex returns the raw lexines in order for the compiler implementor to have complete control over handling what is scanned in 
 * This method decodes them based on which charachter follows the escape character that is scanned in 
 */
void decode_escaped_string(const char *src, char *dest) {
    const char *end = src + strlen(src);

    while (src < end) {
        if (*src == '\\') {            /* Detect the scanned in escape character */
            src++;                     /* Move to the character following the escape character */
            switch (*src) {
                case 'n': *dest++ = '\n'; break; 	/* Newline */
                case 'r': *dest++ = '\r'; break; 	/* Carriage return */
                case '\\': *dest++ = '\\'; break; 	/* Literal backslash */
                case '\"': *dest++ = '\"'; break; 	/* Literal double quote */
                case '0': *dest++ = '\0'; break; 	/* Null character */
                default: *dest++ = *src; break;		/* Pass through and essentially erase '\' when not followed by a valid escape character */
            }
        } else {
            *dest++ = *src;            /* Regular character, just copy it */
        }
        src++;
    }

    *dest = '\0';                      /* Tidy up the destination string with a null terminator */
}

static int set_val(int line_num, int token_class, char *svalue)
{
    /* Instantiate the pass-back data structure and assign its pointer to the YYSTYPEs union token_data_t pointer */
    yylval.token_data = new token_data_t;

    /* Fill the pass-back structure with information regarding this token */
    yylval.token_data->line_num = line_num;
    yylval.token_data->token_str = strdup(svalue);  /* Duplicating string and assigning pointer to first char into member variable token_str*/

    yylval.token_data->token_class = token_class; /* Assigning the token class to member variable token_class */

    if (token_class == NUMBER) {
        yylval.token_data->nvalue = atof(svalue); 
    }
    else if (token_class == ID) {
        yylval.token_data->svalue = strdup(svalue); /* Duplicating string and assigning pointer to first char into member variable svalue */
    }
    else if (token_class == CHAR) {
    	/* Decode escape sequences in the passed in string (in-case of multi-char single quotes) */
    	char decoded_string[1024]; /* Temporary buffer for decoded string, assuming max length of 1024 */
    	decode_escaped_string(svalue, decoded_string); /* Decode escape sequences */
        yylval.token_data->cvalue = decoded_string[1]; /* Assigning the char value to member variable cvalue, ignore first single quote */
    }
    else if (token_class == STRING) {
    	/* Decode escape sequences in the string */
    	char decoded_string[1024]; /* Temporary buffer for decoded string, assuming max length of 1024 */
    	decode_escaped_string(svalue, decoded_string); /* Decode escape sequences */
        yylval.token_data->svalue = strdup(decoded_string); /* Duplicating string and assigning pointer to first char into member variable svalue */
    }
    else if (token_class == OPERATOR) {
	yylval.token_data->svalue = strdup(svalue); /* Duplicating string and assinging to member variable svalue incase of multi char operators (+= etc)*/
    }
    else if (token_class == DELIMITER) {
    	yylval.token_data->cvalue = svalue[0]; /* Only single char delimiters */
    }
    else if (token_class == KEYWORD) {
    	yylval.token_data->svalue = strdup(svalue); /* Duplicating string and assigning pointer to first char into member variable svalue */
    }
    else if (token_class == QUIT) {
	/* No additional data needed for QUIT token */
    }
    else if (token_class == BOOL) {
	if(strcmp(svalue, "true") == 0) {
	    yylval.token_data->nvalue = 1;
	} else {
	    yylval.token_data->nvalue = 0;
	}
    } 

   
    /* Return token_class that was passed in now that yylval has all the token_data_t data */
    return token_class;
}

%}

%option noyywrap

/* REFACTOR REGULAR EXPRESSIONS, once finished with chapter 2 in the book I plan to make these regular expressions more efficient/less ugly if possible */
%%
"stop"|"quit"|"exit"   						{ return set_val(line_num, QUIT, yytext); } /* FOR DEBUGGING NOT INCLUDED IN c- GRAMMAR REMOVE */
"true"|"false"   						{ return set_val(line_num, BOOL, yytext); } /* BOOLCONST token class covers the boolean value keywords */
"int"|"char"|"float"|"double"|"bool"|"void" 			{ return set_val(line_num, KEYWORD, yytext); } /* KEYWORD token class covers the type keywords */
"if"|"else"|"for"|"while"|"do"|"switch"|"case"			{ return set_val(line_num, KEYWORD, yytext); } /* KEYWORD token class covers the control flow keywords */
"return"|"break"|"continue"|"to"|"by"|"then"			{ return set_val(line_num, KEYWORD, yytext); } /* KEYWORD token class covers the control flow keywords */
"static"							{ return set_val(line_num, KEYWORD, yytext); } /* KEYWORD token class covers the control flow keywords */
"+="|"++"|"--"|"-="|"<="|">="|"and"|"or"|"not"|":="|"><"	{ return set_val(line_num, OPERATOR, yytext); } /* Valid operator tokens */
[\%\*\<\>\+\-\=\?] 						{ return set_val(line_num, OPERATOR, yytext); } /* Valid operator tokens */
[0-9]+								{ return set_val(line_num, NUMBER, yytext); } /* Grammar requirements for NUMCONST token class */
[A-Za-z][A-Za-z0-9]*    					{ return set_val(line_num, ID, yytext); } /* Grammar requirements for ID token class */
\'[ \tA-Za-z0-9\"\' \t]\'            			{ return set_val(line_num, CHAR, yytext); } /* Grammar requirements for CHARCONST token class, \t in front and back to 														account for ignored whitespace as per the grammar */
\'\\[n0\\'\"\^@txd]\'    				{ return set_val(line_num, CHAR, yytext); } /* Grammar requirements for CHARCONST VALID newline tokens */
\"([^\"\\\n]|\\.)*\"				{ return set_val(line_num, STRING, yytext); } /* Grammar requirements for STRING token class */
[\{\}\[\]\,\(\)\:\;/] 				{ return set_val(line_num, DELIMITER, yytext); } /* Valid delimiter tokens */
[ \t]                  				; /* Ignore whitespace */
"//"[^\n]*					; /* Ignore single line comments */
\n	                     			{ line_num++; } /*  */
\'[A-Za-z0-9 \^]+\'   				{ printf("WARNING(%d): character is %d characters long and not a single character: '%s'.  The first char will be used.\n",
											line_num, strlen(yytext) - 2, yytext); return set_val(line_num, CHAR, yytext); } 
													/* Warning for single quote strings handled as CHAR */
\'\'\\[t]\'    					{ printf("ERROR(%d): Empty single quotes %s\n", line_num, yytext); num_errors++; } /* Error for empty single quotes ('') */
\'.*^'           				{ printf("ERROR(%d): Malformed char %s\n", line_num, yytext); num_errors++; } /* Error for unclosed char quotes ('.)*/
.                      				{ printf("ERROR(%d): Invalid or misplaced input character: '%c'. Character Ignored.\n", line_num, yytext[0]); num_errors++; }
%%
